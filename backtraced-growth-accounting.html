<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="/theme/css/style.min.css">
  <!--<link rel="stylesheet" type="text/css" href="/theme/css/pygments.min.css">-->
  <link rel="stylesheet" type="text/css" href="/theme/css/pygments/github.css">
  <link rel="stylesheet" type="text/css" href="/theme/css/font-awesome.min.css">
  <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Bytepawn Atom">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />
<meta name="author" content="Marton Trencseni" />
<meta name="description" content="Previously I wrote two articles about data infra and data engineering at Fetchr. This time I want to move up the stack and talk about a simple piece of metrics engineering that proved to be very impactful: Growth Accounting and Backtraced Growth Accounting." />
<meta name="keywords" content="data, science, metrics">
<meta property="og:site_name" content="Bytepawn"/>
<meta property="og:title" content="Growth Accounting and Backtraced Growth Accounting"/>
<meta property="og:description" content="Previously I wrote two articles about data infra and data engineering at Fetchr. This time I want to move up the stack and talk about a simple piece of metrics engineering that proved to be very impactful: Growth Accounting and Backtraced Growth Accounting."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="/backtraced-growth-accounting.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2018-09-16 00:00:00+02:00"/>
<meta property="article:modified_time" content="2018-09-16 00:00:00+02:00"/>
<meta property="article:author" content="/author/marton-trencseni.html">
<meta property="article:section" content="Data"/>
<meta property="article:tag" content="data"/>
<meta property="article:tag" content="science"/>
<meta property="article:tag" content="metrics"/>
<meta property="og:image" content="">  <title>Bytepawn &ndash; Growth Accounting and Backtraced Growth Accounting</title>
</head>
<body>
  <aside>
    <div>
      <a href="/">
        <img src="/theme/img/profile.png" alt="" title="">
      </a>
      <h1><a href=""></a></h1>
      <p></p>
      <nav>
        <ul class="list">
          <li><a href="/">home</a></li>
          <li><a href="https://github.com/mtrencseni">github</a></li>
          <li><a href="https://www.linkedin.com/in/mtrencseni">linkedin</a></li>
          <li><a href="http://arxiv.org/find/all/1/au:+trencseni/0/1/0/all/0/1">arxiv</a></li>
        </ul>
      </nav>
      <ul class="social">
      </ul>
    </div>
  </aside>
  <main>

<article>
  <header>
    <h1 id="backtraced-growth-accounting">Growth Accounting and Backtraced Growth Accounting</h1>
    <p>Posted on Sun 16 September 2018 in <a href="/category/data.html">Data</a></p>
  </header>
  <div>
    <h2>Introduction</h2>
<p>Previously I wrote two articles about data infra and data engineering at Fetchr. This time I want to move up the stack and talk about a simple piece of metrics engineering that proved to be very impactful: Growth Accounting and Backtraced Growth Accounting.</p>
<h2>Standard Growth Accounting</h2>
<p>Let’s start with Growth Accounting, a standard framework for understanding user lifecycles and churn in the SaaS world. I’ve implemented and ran Growth Accounting in previous jobs, but really grasped the importance (and how to do it properly) during my time at Facebook.</p>
<p>The basic framework of Growth Accounting is to assign a state to every object, every day. The possible states are:
  - New
  - Retained
  - Churned
  - Stale
  - Resurrected</p>
<p>First, what is an ‘object’? An object can be anything, like a FB user, a FB group, a Prezi presentation or a Fetchr client company. The second part of Growth Accounting is determining which actions (or lack of them) lead to state transitions. For a user, actions are usually any activity, for a group is any activity in the group, for a Prezi it may be views. The third part of Growth Accounting is fixing the time horizon; this is usually either 1 day (Daily Growth Accounting), 7 days (Weekly) or 28 days (Monthly).</p>
<p>So, before Growth Accounting, we need to decide the:
  - object
  - actions
  - time horizon</p>
<p>The most common use-case for Growth Accounting is users, on a monthly basis, so I’ll stick to that example in the first part:
  - object = users
  - actions = any activity by user
  - time horizon = 28 days</p>
<p>Growth Accounting then says:
  - a user is a Monthly Active User (MAU) if they had any activity in the last 28 days
  - run the below state transitions daily to get the user’s Monthly Growth Accounting state:</p>
<p><img src="/images/ga_state_transitions.png" alt="Growth Accounting State Transitions" style="width: 650px;"/></p>
<p>The same state transition table works for Daily Growth Accounting by replacing MAU with DAU (Daily Active User), and Weekly Growth Accounting by replacing MAU with WAU (Weekly Active User).</p>
<p>Some notes:
  - users are in the New state for only one day (the first), irrespective of whether Growth Accounting is Daily/Weekly/Monthly
  - users are in the Churned state for only one day, irrespective of whether Growth Accounting is Daily/Weekly/Monthly
  - users are in the Resurrected state for only one day (the first active after a period of inactivity), irrespective of whether Growth Accounting is Daily/Weekly/Monthly
  - inactive users end up in the Stale state (when speaking, we tend to say ‘churned users’, but stale is a more accurate term)
  - continuosly active users end up in the Retained state
  - the two states where users bulk up are Retained and Stale</p>
<p>The point of doing Growth Accounting is to count every day the number of New, Retained, etc. users (plus Net New, see below) and put the counts on a time series chart (perhaps a stacked one), and look at it every day. What this usually shows:
  - every product churns out users, so Churned will be non-zero
  - almost every product churns out a lot of users, so Stale will monotonically increase
  - if Churn increases, that’s potentially bad, or the product is just growing
  - if the product is healthy, Retained should increase
  - The Growth Accounting equation is:</p>
<p><code>Net New = New + Resurrected - Churned</code></p>
<ul>
<li>if Net New &gt; 0, that’s good, the MAU count (or DAU or WAU) is increasing</li>
<li>if Net New &lt; 0, that’s bad, the MAU count is decreasing, the product is slowly “dying”</li>
</ul>
<p>Some comments about the Monthly, Weekly, Daily bit:
  - When doing Monthly Growth Account, 1 day of activity is enough to make the user MAU for 28 subsequent days (first they will be New or Resurrected, then Retained for 27 days, then Churned for one day and then Stale, assuming they’re not active again):
  New/Resurrected (1st day) → Retained (2..28) → Churned (29) → Stale (30th day)
  - When doing Daily Growth Accounting, 1 day of activity will make the user DAU for one day, the state transitions will be quick:
  New/Resurrected  (1st day) → Churned (2) → Stale (3rd day)</p>
<p>Usually it makes sense to run all three (D/M/W) and keep tabs on all of them. DAU and WAU respond quicker to problems (with MAU, if there’s a problem, people won’t enter Churned for 28 days after the last activity), but are also more volatile.</p>
<p>As discussed in the introduction Growth Accounting as a framework can be separated from the object and activity definition, and can be run for different time periods. So it makes sense to write it as a modular script that can be reused by plugging in whatever object/action definition. Thinking about tables, Growth Accounting needs as an input just 2 columns:
  - day: a date
  - id: the id of the object
A row like (day, id) simply means that object with id was active on that day. That’s it. Given this table, a starting date, and a choice of D/W/M, a Growth Accounting framework can generate the output:
  - day
  - id
  - state: the growth accounting state of the object with id on day</p>
<p>We use Airflow, our Growth Accounting framework is baked into a function <code>dag_growth_accounting()</code>, and it’s parameterized like:</p>
<p><img src="/images/ga_client.png" alt="B2C Client Growth Accounting" style="width: 650px;"/></p>
<p>This is the definition of our B2C Client Growth Accounting pipeline. The resulting table is <code>client_growth_accounting_28d</code>, the first day for which states are generated is <code>2017-07-01</code> (on that day every object with activity is New), it’s Monthly Growth Accounting, and activity is when we make a delivery for a client. Day is not an explicit column here, the <code>events_table</code> is used as a sub-select in the script for every day when Growth Accounting runs.</p>
<p>There is one additional feature here, there is an additional <code>country</code> column. This makes it possible to filter the charts for country, so we can see per-country counts. This is just a property that is attached to the objects.</p>
<p>The code for the framework function <code>dag_growth_accounting()</code> which creates the Airflow DAG is below:</p>
<script src="https://gist.github.com/mtrencseni/8c93349f12aa48478588a2ecd91d4c1b.js"></script>

<p>Note that this also calculates the L-number for each object: the number of active days in the last X days, where X is 1, 7, 28 depending on whether we're doing D/W/M Growth Accounting.</p>
<h2>Backtraced Growth Accounting</h2>
<p>The challenge we faced at Fetchr is that standard Growth Accounting treats every object the same. One user equals another user, one churned user equals another churned user, and so on. There is no concept of a “more valuable user”.</p>
<p>But when doing Growth Accounting for our B2C client companies, this is not true. If Client X gives us 5,000 deliveries per day, and Client Y gives us 10 deliveries per day, then if Client X churns, that’s a big deal, but Client Y is less important than Client X.</p>
<p>There are various ways to go about this. One possibility is to use the standard Growth Accounting count charts, but weigh each object by their “activity weight”. For example, in our case, we could weigh each client by the number of deliveries they gave us in the last 28 days. But then how do we weigh them once they churn and then become stale? In the end we did not go down this route.</p>
<p>We chose a relatively simple approach, which works well for us:
  - Picture #1: Show Standard Growth Accounting charts to show how clients behave, with each client being weighted equally
  - Picture #2: Also show our historic B2C deliveries, with each delivery (from Client X) colored according to Client X’s current (today’s) Growth Accounting state, historically, all the way back. This “backtracing” is what gives the name of Backtraced Growth Accounting.</p>
<p><img src="/images/ga_picture1.png" alt="Standard Growth Accounting" style="width: 650px;"/></p>
<p><center>Standard Growth Accounting for clients on synthetic data (Picture #1).</center></p>
<p><img src="/images/ga_picture_2.png" alt="Backtraced Growth Accounting" style="width: 650px;"/></p>
<p>The order-wise view on synthetic data (Picture #2).</p>
<p><img src="/images/ga_picture_2_pct.png" alt="Backtraced Growth Accounting" style="width: 650px;"/></p>
<p>The same view, percentage-wise split (Picture #2). This is what I call a sciccor chart.</p>
<p><img src="/images/ga_read_off.png" alt="Backtraced Growth Accounting" style="width: 650px;"/></p>
<p>We can read off what our order-wise “retention” is from a year ago on this synthetic dataset:</p>
<p>How to read the “scissor chart” above:
  - Today, all deliveries are Retained ( if we made a delivery in the last 28 days for a client, that client is Monthly Active, so they will be Retained or Resurrected)
  - As we go back in time, more and more deliveries are “colored” Stale, because they are for clients that don't use us anymore (no delivery in the last 28 days), so they are Stale
  - Going back in time it's easy to read off what % of deliveries were for companies that have already churned out
  - Whales churning/retaining is easy to read off: going backward in time, at the point where a whale churned there will be a jump in Stale deliveries (when they stopped using us)</p>
<p>The big risk of this Picture #2 is that it hides onboarding problems: if a lot of clients come on, try us out by giving us low volume and then leave, it will not dramatically impact such a weighted view. That's not a problem though, that's why we also look Standard Growth Accounting (Picture #1).</p>
<p>Backtraced Growth Accounting like this also makes sense for more common SaaS use-cases:
  - Color (state ↔ color) historic pageviews, message sends, document creates, time spent by the current GA state of the user
  - Color views of a document by the current GA state of the document
  - Color posts in a group by the current GA state of the groupcument (eg. a Prezi)
  - Color deliveries made by a driver by whether the driver is still active with the company (eg. at Fetchr or Uber)</p>
<p>The Backtraced Growth Accounting picture has become a standard part of our thinking when it comes to client retention, but as the examples above show it can also be useful in other product and business settings. Implementing a framework is simple and fun, it can be deployed repeatedly (we run it for both B2C and C2C use-cases), it’s a relatively easy way to get insight and have top-level impact.</p>
<p>At Fetchr, implementing Growth Accounting and Backtraced Growth Accounting had a major impact on our B2C thinking. Before this, other teams ran one-off analysis with arbitrary cuts on (if client X gives us Y orders, but next month they give us 0.6 * Y, then...), which could be tuned to give any desired answer. Standardized Growth Accounting as described in this article gives a clear, parameter-free picture of both our client-wise and order-wise retention. For us, it showed the business is healthy and growing. The Growth Accouting charts today are on CxOs dashboards and are also presented to investors to explain our B2C business.</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="/tag/data.html">data</a>
      <a href="/tag/science.html">science</a>
      <a href="/tag/metrics.html">metrics</a>
    </p>
  </div>
</article>

    <footer>
      <p>&copy; Marton Trencseni </p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p>    </footer>
  </main>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Growth Accounting and Backtraced Growth Accounting",
  "headline": "Growth Accounting and Backtraced Growth Accounting",
  "datePublished": "2018-09-16 00:00:00+02:00",
  "dateModified": "2018-09-16 00:00:00+02:00",
  "author": {
    "@type": "Person",
    "name": "Marton Trencseni",
    "url": "/author/marton-trencseni.html"
  },
  "image": "{{ SITEURL }}/{{ THEME_STATIC_DIR }}/img/profile.png",
  "url": "/backtraced-growth-accounting.html",
  "description": "Previously I wrote two articles about data infra and data engineering at Fetchr. This time I want to move up the stack and talk about a simple piece of metrics engineering that proved to be very impactful: Growth Accounting and Backtraced Growth Accounting."
}
</script></body>
</html>