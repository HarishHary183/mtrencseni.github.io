<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Bytepawn</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2016-02-06T00:00:00+01:00</updated><entry><title>Pinball review</title><link href="/pinball.html" rel="alternate"></link><updated>2016-02-06T00:00:00+01:00</updated><author><name>Marton Trencseni</name></author><id>tag:,2016-02-06:pinball.html</id><summary type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/pinterest/pinball"&gt;Pinball&lt;/a&gt; is Pinterest’s open sourced workflow manager / ETL system. It supports defining several workflows (DAGs) consisting of jobs, and dependencies within jobs. Workflows are defined using a combination of declarative-style Python dictionary objects (like JSON) and Python code referenced in these objects. Pinball comes with a dashboard for checking currently running and past workflows.&lt;/p&gt;
&lt;p&gt;This review will be shorter than the previous &lt;a href="/luigi.html"&gt;Luigi&lt;/a&gt; and &lt;a href="/airflow.html"&gt;Airflow&lt;/a&gt; reviews, because Pinball turned out to be not very interesting to me for the following reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Very little &lt;a href="https://github.com/pinterest/pinball#installation"&gt;documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Very &lt;a href="https://github.com/pinterest/pinball/commits/master"&gt;few recent commits&lt;/a&gt; in the Github repo&lt;/li&gt;
&lt;li&gt;Very &lt;a href="https://github.com/pinterest/pinball/issues?utf8=%E2%9C%93&amp;amp;q=is%3Aissue"&gt;few meaningful answers&lt;/a&gt; to Github issues from the maintainers&lt;/li&gt;
&lt;li&gt;Complicated and undocumented architecture&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unfortunately &lt;code&gt;pip install pinball&lt;/code&gt; doesn’t work and &lt;a href="https://github.com/pinterest/pinball/issues/9"&gt;the maintainers don’t care&lt;/a&gt;, so I didn't invest time in actually trying out Pinball, I just read the source code. Since this review is short and opinionated, I recommend also reading the Pinterest posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://engineering.pinterest.com/blog/pinball-building-workflow-management"&gt;Pinball: Building workflow management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://engineering.pinterest.com/blog/open-sourcing-pinball"&gt;Open-sourcing Pinball&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Architecture&lt;/h2&gt;
&lt;p&gt;Pinball has a modularized architecture. There are 5 modules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Master (sits on the DB)&lt;/li&gt;
&lt;li&gt;Scheduler (also accessed DB)&lt;/li&gt;
&lt;li&gt;Worker (also accessed DB)&lt;/li&gt;
&lt;li&gt;UI web server (also accessed DB)&lt;/li&gt;
&lt;li&gt;Command-line&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The master module sits on top of a &lt;a href="https://www.mysql.com/"&gt;Mysql&lt;/a&gt; database (no others supported) and uses &lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; for ORM. The master exposes a synchronization token API using &lt;a href="https://thrift.apache.org/"&gt;Thrift&lt;/a&gt; to the other modules, and that’s all the master does. I think this is an unnecessary layer of abstraction; the Airflow design decision is better: everybody sees the DB and uses that to communicate, get &lt;a href="https://en.wikipedia.org/wiki/ACID"&gt;ACID&lt;/a&gt; for free; no need to define and maintain an API, no need for Thrift. In the blog post, they say &lt;em&gt;“component-wise design allows for easy alterations”&lt;/em&gt;, eg. you could write a different scheduler implementation. But:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Who’d ever want to write a different scheduler implementation? I'm using an opensource project to avoid writing my own ETL system.&lt;/li&gt;
&lt;li&gt;You can change the code in other architectures as well as long as it’s modularized.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Moving on, the other daemon modules are the scheduler, the worker and the UI web server. The scheduler performs calendar scheduling of workflows. The workers actually execute individual jobs.&lt;/p&gt;
&lt;p&gt;An important piece of the Pinball architecture are tokens. Tokens are basically records, and the collection of all tokens is the system state. Unfortunately the different sort of tokens are not documented, and since Python is dynamic, there’s also no usable documentation in the code (eg. a header file in C++). Tokens have a &lt;code&gt;data&lt;/code&gt; member, and Python objects are pickled and stored there on the fly as the state.
At first when I read the blog posts and code, I saw &lt;a href="https://github.com/pinterest/pinball/blob/master/pinball_system.png"&gt;this diagram&lt;/a&gt; and &lt;a href="https://engineering.pinterest.com/sites/default/files/article/fields/field_image/tumblr_inline_mzxiegqh5c1s1gqll.png"&gt;then this&lt;/a&gt;, and I thought that only the master accesses the database, and the scheduler and workers don’t, everything goes through the master using tokens. But actually that’s not true, I think the architecture is  everybody accesses the database for reads (as an optimization), but only the master writes to the database. This seems like a leaky abstraction, and again it’s not clear why the modules can’t use the DB to communicate state, why the need for Thrift. Relevant parts from the &lt;a href="https://engineering.pinterest.com/blog/pinball-building-workflow-management"&gt;blog post&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Every state (token) change goes through the master and gets committed to the persistent store before the worker request returns… workers can read archived tokens directly from the persistent storage, bypassing the master, greatly improving system scalability.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;An interesting design decision is separation of workflow description, which is given in Python dictionaries, and the actual job codes. &lt;a href="https://github.com/pinterest/pinball/tree/master/pinball_ext/examples"&gt;See example here.&lt;/a&gt; It’s a bit wierd that the workflow references the actual job using a string. I think this is because many modules load the workflow (eg. scheduler), but only the workers actually load the jobs.&lt;/p&gt;
&lt;h2&gt;Contrib stuff&lt;/h2&gt;
&lt;p&gt;Pinball has contrib stuff for the following job types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bash&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;S3 (also EMR)&lt;/li&gt;
&lt;li&gt;Hadoop, Hive&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.qubole.com/"&gt;Qubole&lt;/a&gt; (a data processing platform-as-a-service Pinterest uses)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are no connectors to Postgres, Mysql, Redshift, Presto or any SQL databases.&lt;/p&gt;
&lt;h2&gt;Source code and tests&lt;/h2&gt;
&lt;p&gt;The main codebase is ~18,000 LOC (python), plus about ~7,000 lines of unit test code. Other Python libraries used on the server side:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://thrift.apache.org/"&gt;Thrift&lt;/a&gt; for RPC&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tox.readthedocs.org/"&gt;Tox&lt;/a&gt; for testing&lt;/li&gt;
&lt;li&gt;and a few more…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I think it’s cool that Pinball doesn’t have many library dependencies; for a Python project, it barely has any.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;If I had to build an ETL system from scratch today, I would not use Pinball. It’s not documented, not a lot of commits, can't find other users, and I'm suspicious of the architecture. I would use Airflow.&lt;/p&gt;</summary><category term="data"></category><category term="etl"></category><category term="workflow"></category><category term="pinball"></category></entry><entry><title>How to make a blog like this</title><link href="/how-to-make-a-blog-like-this.html" rel="alternate"></link><updated>2016-01-07T00:00:00+01:00</updated><author><name>Marton Trencseni</name></author><id>tag:,2016-01-07:how-to-make-a-blog-like-this.html</id><summary type="html">&lt;p&gt;Getting your own blog like this is really easy, no server hosting nedded. There are two ingredients:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Github Pages&lt;/li&gt;
&lt;li&gt;the Pelican static blog generator&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Github Pages&lt;/h2&gt;
&lt;p&gt;Suppose your username on github is mtrencseni. Create a repo called &lt;code&gt;mtrencseni.github.io&lt;/code&gt;. Here's mine: &lt;a href="https://github.com/mtrencseni/mtrencseni.github.io"&gt;https://github.com/mtrencseni/mtrencseni.github.io&lt;/a&gt;. Anything you put in there will be served up at &lt;a href="http://mtrencseni.github.io"&gt;http://mtrencseni.github.io&lt;/a&gt;. Try it out for youself, put in an index.html containing &lt;code&gt;Hello world&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Your own domain name with Github Pages&lt;/h2&gt;
&lt;p&gt;I wanted to use my existing domain name &lt;code&gt;bytepawn.com&lt;/code&gt;. Github is so nice, they support this. Put a file called &lt;code&gt;CNAME&lt;/code&gt; into your repo. Here's mine: &lt;a href="https://github.com/mtrencseni/mtrencseni.github.io/blob/master/CNAME"&gt;https://github.com/mtrencseni/mtrencseni.github.io/blob/master/CNAME&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This tells Github to expect requests for this domain. What's left is to tell your DNS provider to use Github. (My registrar is Internet.bs, so much better than Godaddy.) Create an A record that points to &lt;code&gt;192.30.252.153&lt;/code&gt;, this is a Github IP address. That's it. For &lt;code&gt;bytepawn.com&lt;/code&gt; it looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;dig bytepawn.com

&lt;span class="p"&gt;;&lt;/span&gt; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.9.5-3ubuntu0.5-Ubuntu &amp;lt;&amp;lt;&amp;gt;&amp;gt; bytepawn.com
&lt;span class="p"&gt;;;&lt;/span&gt; global options: +cmd
&lt;span class="p"&gt;;;&lt;/span&gt; Got answer:
&lt;span class="p"&gt;;;&lt;/span&gt; -&amp;gt;&amp;gt;HEADER&lt;span class="s"&gt;&amp;lt;&amp;lt;- opco&lt;/span&gt;de: QUERY, status: NOERROR, id: 34353
&lt;span class="p"&gt;;;&lt;/span&gt; flags: qr rd ra&lt;span class="p"&gt;;&lt;/span&gt; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

&lt;span class="p"&gt;;;&lt;/span&gt; OPT PSEUDOSECTION:
&lt;span class="p"&gt;;&lt;/span&gt; EDNS: version: 0, flags:&lt;span class="p"&gt;;&lt;/span&gt; udp: 512
&lt;span class="p"&gt;;;&lt;/span&gt; QUESTION SECTION:
&lt;span class="p"&gt;;&lt;/span&gt;bytepawn.com.                  IN      A

&lt;span class="p"&gt;;;&lt;/span&gt; ANSWER SECTION:
bytepawn.com.           &lt;span class="m"&gt;600&lt;/span&gt;     IN      A       192.30.252.153

&lt;span class="p"&gt;;;&lt;/span&gt; Query &lt;span class="nb"&gt;time&lt;/span&gt;: &lt;span class="m"&gt;19&lt;/span&gt; msec
&lt;span class="p"&gt;;;&lt;/span&gt; SERVER: 172.17.0.1#53&lt;span class="o"&gt;(&lt;/span&gt;172.17.0.1&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;;;&lt;/span&gt; WHEN: Thu Jan &lt;span class="m"&gt;07&lt;/span&gt; 21:36:09 UTC 2016
&lt;span class="p"&gt;;;&lt;/span&gt; MSG SIZE  rcvd: 57
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Generating a static blog&lt;/h2&gt;
&lt;p&gt;Github will serve static content from your repo, it doesn't run any scripts.
So you need to use a static site generator and serve up the generated pages.
Fortunately, there are many.
The two biggest ones are &lt;a href="https://jekyllrb.com/"&gt;Jekyll&lt;/a&gt; for Rubyists and &lt;a href="http://docs.getpelican.com"&gt;Pelican&lt;/a&gt; for Pythonistas.
I'm a Python guy, so I use Pelican.
The &lt;a href="http://docs.getpelican.com/en/3.6.3/quickstart.html"&gt;Pelican quickstart doc&lt;/a&gt; explains how to generate an empty blog. Basically:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pip install pelican markdown
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;blog
&lt;span class="c"&gt;### this is https://github.com/mtrencseni/blog locally&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;pelican-quickstart
&lt;span class="nv"&gt;$ &lt;/span&gt;vi contents/my-first-article.md
&lt;span class="c"&gt;### see the docs what an article should look like&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;pelican content
&lt;span class="c"&gt;### generates static files in the `output` dir&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;cp -R ouput/* ../mtrencseni.github.io
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; ../mtrencseni.github.io
&lt;span class="nv"&gt;$ &lt;/span&gt;git add * &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git commit -m &lt;span class="s2"&gt;&amp;quot;Working :)&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git push
&lt;span class="c"&gt;### it&amp;#39;s live!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Simply copy the contents of Pelican's &lt;code&gt;output&lt;/code&gt; directory into &lt;code&gt;mtrencseni.github.io&lt;/code&gt;, and that's it.&lt;/p&gt;
&lt;h2&gt;Getting a theme for Pelican&lt;/h2&gt;
&lt;p&gt;The default theme is kind of crappy looking.
Fortunately, there's a ton of free themes for Pelican at &lt;a href="http://www.pelicanthemes.com/"&gt;http://www.pelicanthemes.com/&lt;/a&gt;. Here's the github repo for all those themes: &lt;a href="https://github.com/getpelican/pelican-themes"&gt;https://github.com/getpelican/pelican-themes&lt;/a&gt;.
I picked &lt;a href="https://github.com/alexandrevicenzi/Flex"&gt;Flex&lt;/a&gt;, and did some very minor customization on it.
Getting Pelican to use a theme is simple: put a line like &lt;code&gt;THEME = 'flex'&lt;/code&gt; into your &lt;code&gt;pelicanconf.py&lt;/code&gt;, where &lt;code&gt;flex&lt;/code&gt; is the directory containing the theme you picked. Here is mine: &lt;a href="https://github.com/mtrencseni/blog/blob/master/pelicanconf.py"&gt;https://github.com/mtrencseni/blog/blob/master/pelicanconf.py&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Putting it all together&lt;/h2&gt;
&lt;p&gt;I have a repo &lt;a href="https://github.com/mtrencseni/blog"&gt;https://github.com/mtrencseni/blog&lt;/a&gt; which contains the source of the blog. It's a copy of Pelican, with my articles in the &lt;code&gt;content&lt;/code&gt; directory, and a (customized) copy of the flex theme in the &lt;code&gt;flex&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;I use Pelican to generate the static output, and then that gets pushed to &lt;a href="https://github.com/mtrencseni/mtrencseni.github.io"&gt;https://github.com/mtrencseni/mtrencseni.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I customized the Makefile to automate this. Here's mine: &lt;a href="https://github.com/mtrencseni/blog/blob/master/Makefile"&gt;https://github.com/mtrencseni/blog/blob/master/Makefile&lt;/a&gt;. It contains targets for &lt;code&gt;clean&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;preview&lt;/code&gt; and &lt;code&gt;publish&lt;/code&gt;. &lt;code&gt;preview&lt;/code&gt; uses the built in Python webserver to serve up the static site on localhost:8080 for testing. &lt;code&gt;publish&lt;/code&gt; git commits to the &lt;code&gt;mtrencseni.github.io&lt;/code&gt; repo. &lt;/p&gt;
&lt;p&gt;That's it. You can get up an running within a day.&lt;/p&gt;
&lt;h2&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/"&gt;Custom domain with Github pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/9082499/custom-domain-for-github-project-pages"&gt;Stackoverflow help on custom domain setup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://docs.getpelican.com"&gt;Pelican&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pelicanthemes.com/"&gt;Pelican themes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="blog"></category><category term="pelican"></category></entry><entry><title>Airflow review</title><link href="/airflow.html" rel="alternate"></link><updated>2016-01-06T00:00:00+01:00</updated><author><name>Marton Trencseni</name></author><id>tag:,2016-01-06:airflow.html</id><summary type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Airflow is a workflow scheduler written by Airbnb. It supports defining tasks and dependencies as Python code, executing and scheduling them, and distributing tasks across worker nodes. It supports calendar scheduling (hourly/daily jobs, also visualized on the web dashboard), so it can be used as a starting point for traditional ETL. It has a nice web dashboard for seeing current and past task state, querying the history and making changes to metadata such as connection strings.
I wrote this after my &lt;a href="/luigi.html"&gt;Luigi review&lt;/a&gt;, so I make comparisons to Luigi throughout the article.&lt;/p&gt;
&lt;h2&gt;Architecture&lt;/h2&gt;
&lt;p&gt;Airflow is designed to store and persist its state in a relational database such as Mysql or Postgresql. It uses &lt;a href="http://www.sqlalchemy.org/"&gt;SQLAlchemy&lt;/a&gt; for abstracting away the choice of and querying the database. As such much of the logic is implemented as database calls.
It would be fair to call the core of Airflow “an SQLAlchemy app”. This allows for very clean separation of high-level functionality, such as persisting the state itself (done by the database itself), and scheduling, web dashboard, etc.&lt;/p&gt;
&lt;p&gt;Similarly to Luigi, workflows are specified as a DAG of tasks in Python code. But there are many differences. Luigi knows that tasks operate on targets (datasets, files) and includes this abstraction; eg. it checks the existence of targets when deciding whether to run a task (if all output targets exists, there’s no need to run the task). This concept is missing from Airflow, it never checks for the existence of targets to decide whether to run a task. Like in Luigi, tasks depend on each other (and not on datasets). Unlike Luigi, Airflow supports the concept of calendar scheduling, ie. you can specify that a DAG should run every hour or every day, and the Airflow scheduler process will execute it. Unlike Luigi, Airflow supports shipping the task’s code around to different nodes using &lt;code&gt;pickle&lt;/code&gt;, ie. Python binary serialization.&lt;/p&gt;
&lt;p&gt;Airflow also has a webserver which shows dashboards and lets users edit metadata like connection strings to data sources. Since everything is stored in the database, the web server component of Airflow is an independent &lt;a href="http://gunicorn.org/"&gt;gunicorn&lt;/a&gt; process which reads and writes the database.&lt;/p&gt;
&lt;h2&gt;Execution&lt;/h2&gt;
&lt;p&gt;In Airflow, the unit of execution is a &lt;code&gt;Task&lt;/code&gt;. DAG’s are made up of tasks, one &lt;code&gt;.py&lt;/code&gt; file is a DAG. &lt;a href="http://pythonhosted.org/airflow/tutorial.html"&gt;See tutorial.&lt;/a&gt; Although you can tell Airflow to execute just one task, the common thing to do is to load a DAG, or all DAGs in a subdirectory. Airflow loads the &lt;code&gt;.py&lt;/code&gt; file and looks for instances of class &lt;code&gt;DAG&lt;/code&gt;. DAGs are identified by the textual &lt;code&gt;dag_id&lt;/code&gt; given to them in the &lt;code&gt;.py&lt;/code&gt; file. This is important, because this is used to identify the DAG (and it’s hourly/daily instances) throughout Airflow; changing the &lt;code&gt;dag_id&lt;/code&gt; will break dependencies in the state!&lt;/p&gt;
&lt;p&gt;The DAG contains the first date when these tasks should (have been) run (called &lt;code&gt;start_date&lt;/code&gt;), the recurrence interval if any (called &lt;code&gt;schedule_interval&lt;/code&gt;), and whether the subsequent runs should depend on each other (called &lt;code&gt;depends_on_past&lt;/code&gt;). Airflow will interleave slow running DAG instances, ie. it will start the next hour’s jobs even if the last hour hasn’t completed, as long as dependencies permit and overlap limits permit. An instance of a &lt;code&gt;DAG&lt;/code&gt;, eg. one that is running for 2016-01-01 06:00:00 is called a &lt;code&gt;DAGRun&lt;/code&gt;. A &lt;code&gt;DAGRun&lt;/code&gt; is identified by the id of the DAG postfixed by the &lt;code&gt;execution_date&lt;/code&gt; (not when it’s running, ie. not &lt;code&gt;now()&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Tasks, like DAGs are also identified by a textual id. Internally, instances of tasks are instances of &lt;code&gt;TaskInstance&lt;/code&gt;, identified by the task’s &lt;code&gt;task_id&lt;/code&gt; plus the &lt;code&gt;execution_date&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The tasks in a DAG may define dependencies on other tasks using &lt;code&gt;set_upstream()&lt;/code&gt; and &lt;code&gt;set_downstream()&lt;/code&gt;. Airflow will raise an exception when it finds cycles in the DAG.&lt;/p&gt;
&lt;p&gt;A task is a parameterized operator. Airflow provides many types of operators, such as &lt;code&gt;BashOperator&lt;/code&gt; for executing a bash script, &lt;code&gt;HiveOperator&lt;/code&gt; for executing Hive queries, and so on. All these operators derive from &lt;code&gt;BaseOperator&lt;/code&gt;. In line with Airflow being “an SQLAlchemy app”, &lt;code&gt;BaseOperator&lt;/code&gt; is derived from SQLAlquemy's &lt;code&gt;Base&lt;/code&gt; class, so objects can be pushed to the database; this pattern happens throughout Airflow. Operators don’t actually contain the database specific API calls (eg. for Hive or Mysql); this logic is contained in hooks, eg. class &lt;code&gt;HiveCliHook&lt;/code&gt;. All hooks are derived from class &lt;code&gt;BaseHook&lt;/code&gt;, a common interface for connecting and executing queries. So, whereas Luigi has one &lt;code&gt;Target&lt;/code&gt; class (and subclasses), in Airflow this logic is distributed into operators and hooks.&lt;/p&gt;
&lt;p&gt;There are 3 main type of operators (all three use the same hook classes to accomplish their job):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Sensor:&lt;/strong&gt; Waits for events to happen. This could be a file appearing in HDFS, the existence of a Hive partition, or waiting for an arbitrary MySQL query to return a row.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Remote Execution:&lt;/strong&gt; Triggers an operation in a remote system. This could be an HQL statement in Hive, a Pig script, a map reduce job, a stored procedure in Oracle or a Bash script to run.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data transfers:&lt;/strong&gt; Move data from one system to another. Push data from Hive to MySQL, from a local file to HDFS, from Postgres to Oracle, or anything of that nature.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The most interesting are sensors. They allow tasks to depend on special “sensor tasks”, which are actually files or datasets. A sensor let’s you specify how often it should be checked (default 1 minute), and when it should time out (default 1 week). These are all derived from class &lt;code&gt;BaseSensorOperator&lt;/code&gt;. There is a special sensor called &lt;code&gt;ExternalTaskSensor&lt;/code&gt;, which lets a task depend on another task (specified by a &lt;code&gt;dag_id&lt;/code&gt; and a &lt;code&gt;task_id&lt;/code&gt; and &lt;code&gt;execution_date&lt;/code&gt;) in another DAG, since this is not supported “by default”. &lt;code&gt;ExternalTaskSensor&lt;/code&gt; actually just checks what the specified record looks like in the Airflow state database.&lt;/p&gt;
&lt;p&gt;All operators have a &lt;code&gt;trigger_rule&lt;/code&gt; argument which defines the rule by which the generated task get triggered. The default value for &lt;code&gt;trigger_rule&lt;/code&gt; is &lt;code&gt;all_success&lt;/code&gt; and can be defined as “trigger this task when all directly upstream tasks have succeeded. Others are: &lt;code&gt;all_failed&lt;/code&gt;, &lt;code&gt;all_done&lt;/code&gt;, &lt;code&gt;one_failed&lt;/code&gt;, &lt;code&gt;one_success&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Scheduling and executors&lt;/h2&gt;
&lt;p&gt;Recap: Airflow supports calendar scheduling (hour/daily tasks). Each such run is an instance of a DAG (internally, a &lt;code&gt;DAGRun&lt;/code&gt; object), with tasks and their dependencies. As mentioned previously, DAGs can depend on their previous runs (&lt;code&gt;depends_on_past&lt;/code&gt;), and additionally, specific task dependencies across DAGs is possible with the &lt;code&gt;ExternalTaskSensor&lt;/code&gt; operator. The maximum number of DAG runs to allow per DAG can be limited with &lt;code&gt;max_active_runs_per_dag&lt;/code&gt; in &lt;code&gt;airflow.cfg&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When running Luigi, we have to specify what sort of executor to use in &lt;code&gt;airflow.cfg&lt;/code&gt;: &lt;code&gt;SequentialExecutor&lt;/code&gt;, &lt;code&gt;LocalExecutor&lt;/code&gt; or &lt;code&gt;CeleryExecutor&lt;/code&gt;; all three derive from &lt;code&gt;BaseExecutor&lt;/code&gt;. The sequential executor runs locally in a single process/thread, and waits for each task to finish before starting the next one; it should only be used for testing/debugging. The &lt;code&gt;LocalExecutor&lt;/code&gt; also runs tasks locally, but spawns a new process for each one using &lt;code&gt;subprocess.popen()&lt;/code&gt; to run a new &lt;code&gt;bash&lt;/code&gt;; the maximum number of processes can be configured with &lt;code&gt;parallelism&lt;/code&gt; in &lt;code&gt;airflow.cfg&lt;/code&gt;. Inside the &lt;code&gt;bash&lt;/code&gt;, it runs an &lt;code&gt;airflow&lt;/code&gt;, parameterized to just run the a given &lt;code&gt;dag_id&lt;/code&gt; &lt;code&gt;task_id&lt;/code&gt; &lt;code&gt;execution_date&lt;/code&gt; combination using the &lt;code&gt;airflow&lt;/code&gt; run command line parametrization. The python code belonging to the task is read back from the database (where it was stored by the scheduler using &lt;code&gt;pickle&lt;/code&gt;). The &lt;code&gt;CeleryExecutor&lt;/code&gt; works similarly, except the job is pushed inside a distributed &lt;a href="http://www.celeryproject.org/"&gt;celery&lt;/a&gt; queue.&lt;/p&gt;
&lt;p&gt;When running Airflow, internally a number of jobs are created. A job is a long running something that handles running  smaller units of work; all jobs derive from &lt;code&gt;BaseJob&lt;/code&gt;. There is &lt;code&gt;SchedulerJob&lt;/code&gt;, which manages a single DAG (creates DAG runs, task instances, manages priorities),  &lt;code&gt;BackfillJob&lt;/code&gt; for backfilling a specific DAG, and &lt;code&gt;LocalTaskJob&lt;/code&gt; when running a specific &lt;code&gt;dag_id&lt;/code&gt; &lt;code&gt;task_id&lt;/code&gt; &lt;code&gt;execution_date&lt;/code&gt; combination (as requested by the &lt;code&gt;LocalExecutor&lt;/code&gt; or the &lt;code&gt;CeleryExecutor&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;When running the airflow scheduler, the &lt;code&gt;SchedulerJob&lt;/code&gt; supports loading DAGs from a folder: in this case, new code added/changed is automatically detected and loaded. This is very convenient, because new code just has to be placed on the production server, and it’s automatically picked up by Airflow.&lt;/p&gt;
&lt;p&gt;So in Airflow there is no need to start worker processes: workers are spawned as subprocesses by the &lt;code&gt;LocalExecutor&lt;/code&gt; or remotely by celery. Also, more than one scheduler/executor/main process can run, sitting on the main database. When running tasks, Airflow creates a lock in the database to make sure tasks aren’t run twice by schedulers; other parallelism is enforced by unique database keys (eg. only one &lt;code&gt;dag_id&lt;/code&gt; &lt;code&gt;execution_date&lt;/code&gt; combination allowed to avoid schedulers creating multiple &lt;code&gt;DAGRun&lt;/code&gt; copies). &lt;em&gt;Note: I’m not sure what the point would be of running several schedulers, other than redundancy, and whether this truly works without hiccups; the TODO file includes this todo item: “Distributed scheduler”.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Airflow supports pools to limit parallelism of certain types of tasks (eg. limit number of bash jobs, limit number of Hive connections); this is similar to Luigi resources. Priorities are also supported: The default &lt;code&gt;priority_weight&lt;/code&gt; is 1, and can be bumped to any number. When sorting the queue to evaluate which task should be executed next, Airflow uses the &lt;code&gt;priority_weight&lt;/code&gt;, summed up with all of the &lt;code&gt;priority_weight&lt;/code&gt; values from tasks downstream from this task.&lt;/p&gt;
&lt;p&gt;Airflow supports heartbeats. Each job will update a heartbeat entry in the database. If a job hasn’t updated it’s heartbeat for a while, it’s assumed that it has failed and it’s state is set to &lt;code&gt;SHUTDOWN&lt;/code&gt; in the database. This also allows for any job to be killed externally, regardless of who is running it or on which machine it is running. &lt;em&gt;Note: I’m not sure how this works, because from my reading of the code, the actual termination of the process that didn’t send the heartbeat should be performed by the process itself; but if it stuck or blocked and didn’t send a heartbeat, then how will it notice it should shut itself down?&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Other interesting features&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SLAs:&lt;/strong&gt; Service Level Agreements, or time by which a task or DAG should have succeeded, can be set at a task level as a timedelta. If one or many instances have not succeeded by that time, an alert email is sent detailing the list of tasks that missed their SLA. The event is also recorded in the database and made available in the web UI under Browse -&amp;gt; Missed SLAs where events can be analyzed and documented.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XCom:&lt;/strong&gt; XComs let tasks exchange messages, allowing more nuanced forms of control and shared state. The name is an abbreviation of “cross-communication”. XComs are principally defined by a key, value, and timestamp, but also track attributes like the task/DAG that created the XCom and when it should become visible. Any object that can be pickled can be used as an XCom value, so users should make sure to use objects of appropriate size. XComs can be “pushed” (sent) or “pulled” (received). When a task pushes an XCom, it makes it generally available to other tasks. Tasks can push XComs at any time by calling the &lt;code&gt;xcom_push()&lt;/code&gt; method. In addition, if a task returns a value (either from its Operator’s &lt;code&gt;execute()&lt;/code&gt; method, or from a &lt;code&gt;PythonOperator&lt;/code&gt;’s &lt;code&gt;python_callable()&lt;/code&gt; function), then an XCom containing that value is automatically pushed. Tasks call &lt;code&gt;xcom_pull()&lt;/code&gt; to retrieve XComs, optionally applying filters based on criteria like key, source &lt;code&gt;task_id&lt;/code&gt;s, and source &lt;code&gt;dag_id&lt;/code&gt;. By default, &lt;code&gt;xcom_pull()&lt;/code&gt; filters for the keys that are automatically given to XComs when they are pushed by being returned from execute functions (as opposed to XComs that are pushed manually).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Variables:&lt;/strong&gt; Variables are a generic way to store and retrieve arbitrary content or settings as a simple key value store within Airflow. Variables can be listed, created, updated and deleted from the UI (Admin -&amp;gt; Variables) or from code. While your pipeline code definition and most of your constants and variables should be defined in code and stored in source control, it can be useful to have some variables or configuration items accessible and modifiable through the UI.&lt;/p&gt;
&lt;h2&gt;Contrib stuff&lt;/h2&gt;
&lt;p&gt;Like Luigi, Airflow has an impressive library of stock operator classes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bash&lt;/li&gt;
&lt;li&gt;Mysql&lt;/li&gt;
&lt;li&gt;Postgresql&lt;/li&gt;
&lt;li&gt;MSSQL&lt;/li&gt;
&lt;li&gt;Hive&lt;/li&gt;
&lt;li&gt;Presto&lt;/li&gt;
&lt;li&gt;HDFS&lt;/li&gt;
&lt;li&gt;S3&lt;/li&gt;
&lt;li&gt;HTTP sensor&lt;/li&gt;
&lt;li&gt;and many more...
Redshift is currently not supported.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Source code and tests&lt;/h2&gt;
&lt;p&gt;The main codebase is ~21,000 LOC (python, js, html), plus  about ~1,200 lines of unit test code.
Other Python libraries used on the server side:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.sqlalchemy.org/"&gt;SQLAlchemy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jinja.pocoo.org/"&gt;Jinja&lt;/a&gt; for templating (why, if we’re using Python code to define jobs anyway?)&lt;/li&gt;
&lt;li&gt;&lt;a href="http://gunicorn.org/"&gt;Gunicorn&lt;/a&gt; and &lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; for HTTP&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pypi.python.org/pypi/dill"&gt;Dill&lt;/a&gt; for pickling&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tox.readthedocs.org"&gt;Tox&lt;/a&gt; for testing
and many more...&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Airflow’s design decisions are very close to my heart: the fact that it’s an SQLAlchemy app make managing state, restarting the daemon, or running more in parallel very easy.  It has lots of contrib stuff baked in, so it’s easy to get started. The dashboard is very nice, and also shows historic runs nicely color-coded. If I were to build a new ETL system, I would definitely consider using Airflow (over Luigi, since Airflow has many more features out of the box).&lt;/p&gt;
&lt;p&gt;What I don’t like about Airflow:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Apart from special sensor operators, doesn’t deal with files/datasets as inputs/outputs of tasks directly. This I find an odd design decision, as it leads to some complications:&lt;ul&gt;
&lt;li&gt;The state database stores the state of tasks, not the datasets; if the state database is lost, it’s hard to restore the historic state of the ETL, even if all the datasets are there. It’s better to separate datasets and tasks, and represent the historic state of ETL using the state of the datasets&lt;/li&gt;
&lt;li&gt;It’s harder to deal with tasks that appear to finish correctly, but don’t actually produce output, or good output. In the Airflow architecture this problem only shows up later, when a task downstream (hopefully) errors out. This can happen eg. if a bash script forgets to set -e.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I think it’d be better if workers could be started independently, and picked up tasks scheduled by a central scheduler; instead Airflow starts workers centrally.&lt;/li&gt;
&lt;li&gt;Still a work in progress, not many tests, probably will run into bugs in production. Also see the end of &lt;a href="https://medium.com/handy-tech/airflow-tips-tricks-and-pitfalls-9ba53fba14eb#.lzfjq4wx9"&gt;this blog post&lt;/a&gt;, they restart the Airflow process pretty often because of some bug.&lt;/li&gt;
&lt;li&gt;Personally, I'm still not convinced that the ETL-job-as-code is the right way to go.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Links, talks&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/airbnb/airflow"&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://airflow.readthedocs.org"&gt;Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/airbnb/airflow#links"&gt;Slides from Airflow users&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="data"></category><category term="etl"></category><category term="workflow"></category><category term="airflow"></category></entry><entry><title>Systems thinking and system traps</title><link href="/systems-thinking.html" rel="alternate"></link><updated>2016-01-06T00:00:00+01:00</updated><author><name>Marton Trencseni</name></author><id>tag:,2016-01-06:systems-thinking.html</id><summary type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/gp/product/1603580557/ref=pd_lpo_sbs_dp_ss_1?pf_rd_p=1944687762&amp;amp;pf_rd_s=lpo-top-stripe-1&amp;amp;pf_rd_t=201&amp;amp;pf_rd_i=0123859158&amp;amp;pf_rd_m=ATVPDKIKX0DER&amp;amp;pf_rd_r=181NKCEKSEPQ62PT0S07"&gt;Thinking in Systems&lt;/a&gt;, written by the late &lt;a href="https://en.wikipedia.org/wiki/Donella_Meadows"&gt;Donella Meadows&lt;/a&gt;, is a book about how to think about systems, how to control systems and how systems change and control themselves. A system can be anything from a heating furnace to a social system. The book is conceptual, there’s not a single equation in it, it's not about differential equations or control theory.&lt;/p&gt;
&lt;h2&gt;System traps&lt;/h2&gt;
&lt;p&gt;The gem of the book is the part about &lt;em&gt;system traps&lt;/em&gt;. System traps are ways a system can go wrong. It’s really interesting to read about system traps and then notice and observe them in action: in micro environments such as a company and in macro environments such as an industry or a  country. Here’s a list of the most interesting system traps from the book, with some examples.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Policy resistance:&lt;/strong&gt; The inherent resistance of the establishment to allow changes to affect the system. People would rather live with a flawed system that is familiar then to allow changes that might cause uncertainty and instability. Such resistance can cause inevitable collapse to be more dramatic, sometime even catastrophic.&lt;br /&gt;
Example: &lt;a href="http://www.wsj.com/articles/obama-to-discuss-gun-control-options-with-attorney-general-1451646004"&gt;US citizens resisting Obama’s gun control changes.&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Drift to low performance:&lt;/strong&gt; The notion that prolonged failures causes acceptance of the new state of things, “new normal”.&lt;br /&gt;
Example: a great example is soccer in Hungary. Hungary used to have a very strong soccer culture, but over time quality decayed to the point where today, a draw or only getting defeated by 1 goal is considered a good result. All this even though the hungarian government is investing large amounts into the sport. The root cause for this sustained drift to low performance seems to be that soccer is used as a way to channel money from the government to private individuals, ie. corruption.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Seeking wrong goals:&lt;/strong&gt; Sometime goals change. Many systems suffer from the fact that original goal don’t make any sense in the current context, or never did. Pursuit of wrong goals will cause the system pursue these goals, capturing wrong or insignificant metrics, leaving the illusion of progress, while heading toward system collapse.&lt;br /&gt;
Example: &lt;a href="http://techcrunch.com/2011/07/30/vanity-metrics/"&gt;startups seeking to increase vanity metrics&lt;/a&gt; such as registered users and bookings instead of engagement and profits.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Shifting the burden:&lt;/strong&gt; Notion that risk is shifted to someone else, while success is reaped by the actor.&lt;br /&gt;
Example: &lt;a href="https://hbr.org/2013/05/six-myths-about-venture-capitalists"&gt;venture capitalists and hedge fund managers work under a model&lt;/a&gt; where they get a nice base salary, a nice bonus if their fund performs well, but there is no downside for them. Turn around times are on the order of 10 years, so there’s little historic data on fund manager’s performance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The tragedy of commons:&lt;/strong&gt; This is classic economic theory, described in terms of system thinking. The common, defined as community space – such as a town common, is a shared resource. This resource can be governed by community standards, privatization or effective regulation. Each approach has tradeoffs and benefits. It’s the conclusion of the [Donella Meadows] that only regulation is effective since the community standards are usually not enough.&lt;br /&gt;
Example: &lt;a href="https://en.wikipedia.org/wiki/Cybersquatting"&gt;domain name squatting&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Success to the Successful:&lt;/strong&gt; The notion that success will give advantage to those that have already succeeded, thus limiting the “losers” ability to win in the future. “The rich get richer!”&lt;br /&gt;
Example: that’s how it is everywhere, see &lt;a href="http://www.economist.com/blogs/economist-explains/2014/05/economist-explains"&gt;Thomas Piketty’s book Capital&lt;/a&gt;. A more specific example is entrepreneurs who’ve had a successful startup previous have an easier time raising money for their next startup. Surprisingly, &lt;a href="https://hbr.org/2014/02/research-serial-entrepreneurs-arent-any-more-likely-to-succeed/"&gt;data doesn’t show a correlation between past and future success&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rule beating:&lt;/strong&gt; The notion that rules, or laws, are ignored, broken or skirted. The cause of rule breaking is usually related to the fact that these rules are perceived as unjust or not flexible enough wrt real life issues.&lt;br /&gt;
Example: there’s a whole industry called &lt;a href="https://en.wikipedia.org/wiki/Search_engine_optimization"&gt;SEO&lt;/a&gt; to &lt;a href="https://www.quora.com/What-techniques-do-websites-use-to-game-the-Google-search-engine"&gt;game search engine rankings&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="systems"></category><category term="books"></category></entry><entry><title>Luigi review</title><link href="/luigi.html" rel="alternate"></link><updated>2015-12-22T00:00:00+01:00</updated><author><name>Marton Trencseni</name></author><id>tag:,2015-12-20:luigi.html</id><summary type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Luigi is an execution framework for writing data pipes in Python code. It supports task-task dependencies, it has a simple central scheduler with an HTTP API and an extensive library of helpers for building data pipes for Hadoop, AWS, Mysql etc. It was written by Spotify for internal use and open sourced in 2012. A number of companies use it, such as Foursquare, Stripe, Asana.&lt;/p&gt;
&lt;h2&gt;Execution&lt;/h2&gt;
&lt;p&gt;Suppose that part of your ETL process is to take some data A, apply transformation X on it, and save it as Y. In Luigi, you would write a &lt;code&gt;.py&lt;/code&gt; file which contains a class X, which derives from class &lt;code&gt;Task&lt;/code&gt;. X would have three methods: &lt;code&gt;requires(), run(), and output()&lt;/code&gt;.&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;luigi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;requires&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Then you execute luigi and pass this &lt;code&gt;.py&lt;/code&gt; file to it, like &lt;code&gt;luigi --module x X&lt;/code&gt; if the file name is &lt;code&gt;x.py&lt;/code&gt;. When given a &lt;code&gt;Task&lt;/code&gt;, luigi:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Calls the &lt;code&gt;output()&lt;/code&gt; method, which returns one or more objects deriving from class &lt;code&gt;Target&lt;/code&gt;. A &lt;code&gt;Target&lt;/code&gt; is something which has an &lt;code&gt;exists()&lt;/code&gt; method which returns either &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. Luigi calls &lt;code&gt;exists()&lt;/code&gt; on all the targets to see whether they exist. If all return &lt;code&gt;True&lt;/code&gt;, luigi will flag this task as &lt;code&gt;DONE&lt;/code&gt; and never call &lt;code&gt;run()&lt;/code&gt;.
   If at least one of the output targets returned &lt;code&gt;False&lt;/code&gt;, this job needs to be run.&lt;/li&gt;
&lt;li&gt;Luigi then calls the &lt;code&gt;requires()&lt;/code&gt; method to see what other tasks need to first run for this task to run successfully. &lt;code&gt;requires()&lt;/code&gt; returns one or more objects deriving from class &lt;code&gt;Task&lt;/code&gt;, and recursively performs this process for all those.
   Note: after returning, luigi checks whether the output targets of the required tasks really exists. This is encapsulated in the &lt;code&gt;complete()&lt;/code&gt; method, the default implementation just calls &lt;code&gt;exists()&lt;/code&gt; on all targets returned by &lt;code&gt;output()&lt;/code&gt;; the method can optionally be overridden in the derived &lt;code&gt;Target&lt;/code&gt; class. The purpose of &lt;code&gt;complete()&lt;/code&gt; is to make sure &lt;code&gt;run()&lt;/code&gt; was successful, because if a required target’s &lt;code&gt;run()&lt;/code&gt; didn’t raise a Python exception but didn’t actually produce the output needed, then &lt;code&gt;run()&lt;/code&gt; shouldn’t be called. In this case the required task is re-run.&lt;/li&gt;
&lt;li&gt;Luigi calls the &lt;code&gt;run()&lt;/code&gt; method and sets the task status to &lt;code&gt;DONE&lt;/code&gt; if no Python exceptions were raised.
   Note: &lt;code&gt;run()&lt;/code&gt; can also dynamically &lt;code&gt;yield&lt;/code&gt; dependencies tasks.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Local and central scheduler&lt;/h2&gt;
&lt;p&gt;When luigi is launched and a task is given to it a &lt;code&gt;Worker&lt;/code&gt; object is created. Workers need to talk to a &lt;code&gt;Scheduler&lt;/code&gt;, which manages the dependency graph of tasks and tells workers what to do. So when the local worker object is created, it can either:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a local scheduler in the process, or&lt;/li&gt;
&lt;li&gt;Connect to a remote scheduler using the HTTP API. This is the default.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Local scheduler:&lt;/em&gt; The local scheduler can be used by passing &lt;code&gt;--local-scheduler&lt;/code&gt; to the luigi runtime. When running with the local scheduler, the algorithm given above is run recursively, and then luigi exits. This is usually only used for testing and debugging purposes.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Central scheduler:&lt;/em&gt; More interesting is the central scheduler. The central scheduler is a separate &lt;code&gt;luigid&lt;/code&gt; Python Tornado app that workers can talk to over HTTP. It performs two tasks: scheduling of tasks based on the dependency graph and serving a simple web dashboard on port 8082 (default). Note that the central scheduler:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Doesn’t see or execute the &lt;code&gt;Task&lt;/code&gt; object's code, hence it never sees or checks whether targets exist; this is always performed by workers.&lt;/li&gt;
&lt;li&gt;The task is identified by its signature:&lt;ul&gt;
&lt;li&gt;Python name of the class; in the example above it’s X.&lt;/li&gt;
&lt;li&gt;The values of the parameters passed to the task, eg. &lt;code&gt;day=2015-12-01&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Parameters are member variables in the &lt;code&gt;Task&lt;/code&gt; objects which derive from class &lt;code&gt;Parameter&lt;/code&gt;, eg.:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;luigi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;day&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;luigi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DateParameter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;today&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;By specifying &lt;code&gt;significant=False&lt;/code&gt; in the &lt;code&gt;Parameter&lt;/code&gt; constructor, we can tell Luigi not to treat it as part of the task signature.&lt;/p&gt;
&lt;p&gt;The worker builds the local dependency graph and then uploads it to the central scheduler. Then it asks the central scheduler what it should do. The central scheduler potentially receives dependency graphs from several workers, and merges them, assuming tasks with the same name (and parameter values) uploaded from different workers are the same (generate the same &lt;code&gt;output()&lt;/code&gt; targets, contain the same &lt;code&gt;run()&lt;/code&gt; logic, etc).&lt;/p&gt;
&lt;p&gt;Given the dependency graph, the central scheduler then tells workers to start running tasks. A worker can only run tasks that it uploaded to the central scheduler, because those are the tasks that that Python process loaded. So workers are not generic workers, they can only work on the tasks that they were started with!&lt;/p&gt;
&lt;p&gt;Given a dependency graph, the scheduler will tell workers to run tasks that have no dependencies. By default, the order is non-deterministic. However, tasks can specify a priority, tasks with higher priority run first. The default priority is 0. Example:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;luigi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nd"&gt;@property&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Because priorities are in code, the worker must evaluate them and pass it on to the central scheduler.&lt;/p&gt;
&lt;h2&gt;Local parallelism&lt;/h2&gt;
&lt;p&gt;More than 1 worker thread can be created by passing &lt;code&gt;--workers N&lt;/code&gt; to luigi. This is registered to the central scheduler, and if possible N tasks are run in parallel by one worker.
So there are multiple levels of parallelism in Luigi:
1. Multiple workers
2. Multiple threads in workers
3. Each task can have further parallelism, eg. a Hadoop MapReduce job.&lt;/p&gt;
&lt;h2&gt;Managing a library of tasks&lt;/h2&gt;
&lt;p&gt;What if we’re managing a library of 100s or 1000s of ETL jobs? While I haven’t used Luigi for this, it seems that the basic building blocks are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Python &lt;code&gt;import&lt;/code&gt; statements: our jobs are distributed into different &lt;code&gt;.py&lt;/code&gt; files, so we need to &lt;code&gt;import&lt;/code&gt; them to use them in &lt;code&gt;requires()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WrapperTask&lt;/code&gt; objects: these are special sink tasks which don’t have an output, they just require other tasks to be run.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This part puts a lot of work on the user of Luigi:
1. If we create a new task and forget to add it to the sink task, it won’t be executed (unless it’s a dependency for something else).
2. If we refactor a job (eg. rename the task class, change parameters), we have to search and replace all references in subsequent &lt;code&gt;requires()&lt;/code&gt; methods. Since Python isn’t a statically typed language, this has to be done by hand.
3. If running workers on separate machines, it’s our job to synchronize the library of &lt;code&gt;.py&lt;/code&gt; files (eg. using &lt;code&gt;git&lt;/code&gt; and &lt;code&gt;cron&lt;/code&gt; jobs to sync very often). Different versions of tasks with different logic or local, uncommitted changes propagating to the central scheduler will lead to hard to find bugs and data corruption.&lt;/p&gt;
&lt;h2&gt;Date parameters&lt;/h2&gt;
&lt;p&gt;In an ETL system, most tasks will have a date(time) parameter which tells the code which day/hour to run the scripts for. For example, a Daily Active User (DAU) script computes the number of unique DAUs for a given day. Because this is such a common use-case, Luigi has a number of helper classes for dealing with date parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://luigi.readthedocs.org/en/stable/api/luigi.parameter.html#luigi.parameter.DateParameter"&gt;DateParameter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://luigi.readthedocs.org/en/stable/api/luigi.parameter.html#luigi.parameter.MonthParameter"&gt;MonthParameter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://luigi.readthedocs.org/en/stable/api/luigi.parameter.html#luigi.parameter.YearParameter"&gt;YearParameter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://luigi.readthedocs.org/en/stable/api/luigi.parameter.html#luigi.parameter.DateHourParameter"&gt;DateHourParameter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://luigi.readthedocs.org/en/stable/api/luigi.parameter.html#luigi.parameter.DateMinuteParameter"&gt;DateMinuteParameter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://luigi.readthedocs.org/en/stable/api/luigi.parameter.html#luigi.parameter.DateIntervalParameter"&gt;DateIntervalParameter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Often tasks have to be re-run for a number of days. One way to do this is to call luigi repeatedly from the command line. Or we can use the built in &lt;code&gt;RangeDailyBase&lt;/code&gt; (also &lt;code&gt;RangeHourlyBase&lt;/code&gt;) helpers:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# instead of calling this repeatedly:&lt;/span&gt;
    &lt;span class="c"&gt;# luigi task Task --date 2015-01-XX&lt;/span&gt;
&lt;span class="c"&gt;# do this:&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;luigi --module task RangeDailyBase --of Task --start 2015-01-01 --stop 2015-01-31
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The name of the date parameter of the task can be specified with &lt;code&gt;--param_name==&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When we pass in a large number of dates (as an interval), the &lt;code&gt;RangeXBase&lt;/code&gt; classes will instantiate a task object for each date and call &lt;code&gt;complete()&lt;/code&gt; to check whether that task needs to be run. This can be very slow, eg. if each one creates a database connection and then closes it down.
There are two optimization classes &lt;code&gt;RangeDaily&lt;/code&gt; and &lt;code&gt;RangeHourly&lt;/code&gt; that solve this problem. These are used just like the two &lt;code&gt;Base&lt;/code&gt; versions from the command line. But instead of instantiating many tasks which potentially don’t have to be run, they assume and call the task’s &lt;code&gt;bulk_complete()&lt;/code&gt; classmethod to get a list of dates which have to be run. So the user has to implement a &lt;code&gt;bulk_complete()&lt;/code&gt; to use &lt;code&gt;RangeDaily&lt;/code&gt; and &lt;code&gt;RangeHourly&lt;/code&gt;.&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;luigi --module task RangeDaily --of Task --start 2015-01-01 --stop 2015-01-31
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Note: it seems Luigi doesn’t support bulk &lt;em&gt;running&lt;/em&gt; of parameter intervals.&lt;/p&gt;
&lt;h2&gt;Scheduling&lt;/h2&gt;
&lt;p&gt;Most ETL systems have jobs which need to run every hour or every day. Luigi doesn’t have a concept of calendar scheduling, this is up to the user. The recommended method by the authors is to create sink tasks and run them from &lt;code&gt;cron&lt;/code&gt; when the external input files (eg. raw log files) are likely to be available.&lt;/p&gt;
&lt;p&gt;Rescheduling failed tasks is influenced by the following parameters in the central scheduler’s &lt;code&gt;luigi.cfg&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;retry-delay&lt;/code&gt;: when to re-schedule, default 900 seconds&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove-delay&lt;/code&gt;: how long the central scheduler keeps tasks around that have no stakeholder; a stakeholder is a worker who uploaded that task&lt;/li&gt;
&lt;li&gt;&lt;code&gt;disable-hard-timeout&lt;/code&gt;: if a task fails again after this much time, it is disabled for good&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the worker’s &lt;code&gt;luigi.cfg&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;worker-keep-alive&lt;/code&gt;: you probably need to set this to true, so workers will stay alive when they run out of jobs to run, as long as they have some pending job waiting to be run. Otherwise workers will disconnect from the central scheduler and exit if there’s nothing to do, even if there are tasks which will be scheduled a few minutes from now.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;retry-external-tasks&lt;/code&gt;: If true, incomplete external tasks (i.e. tasks where the &lt;code&gt;run()&lt;/code&gt; method is &lt;code&gt;NotImplemented&lt;/code&gt;) will be retested for completion while Luigi is running. This means that if external dependencies are satisfied after a workflow has started, any tasks dependent on that resource will be eligible for running.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The central scheduler has a feature called task history. This logs task completion to a database, and exposes it on the dashboard.&lt;/p&gt;
&lt;p&gt;For tasks where the output is a database table, Luigi needs to keep track of successful inserts. It uses a special marker table for this (set with &lt;code&gt;marker-table&lt;/code&gt; in &lt;code&gt;luigi.cfg&lt;/code&gt;, default name is &lt;code&gt;table_updates&lt;/code&gt;). When a task finishes whose target is a database table, an entry is created in the marker table with the task’s &lt;code&gt;task_id&lt;/code&gt; (its name and parameter values). When the target’s &lt;code&gt;exists()&lt;/code&gt; method is called, this marker table is queried to check whether the task has been run (the &lt;code&gt;task_id&lt;/code&gt; is passed by the task to the &lt;code&gt;Target&lt;/code&gt; in its constructor).&lt;/p&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;p&gt;Resources can be used to introduce limits on task parallelism. For example, suppose we never want to run more than 10 mysql tasks, or we never want to run more than 3 instances of the hourly job &lt;code&gt;count_users&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Resources are declared in the &lt;code&gt;luigi.cfg&lt;/code&gt; file of the scheduler:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;resources&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;count_users&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Resource use is given in the resources property of the task object in the Python code, like:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;resources&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c"&gt;# using 2 mysql connections in this task&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;Contrib stuff&lt;/h2&gt;
&lt;p&gt;Luigi has an impressive library of stock &lt;code&gt;Target&lt;/code&gt; and &lt;code&gt;Task&lt;/code&gt; classes, each with lots of functionality baked in as helper methods. This is the big reason why I think Luigi is popular and why I would consider using it.&lt;/p&gt;
&lt;p&gt;Luigi has &lt;code&gt;Task&lt;/code&gt; and &lt;code&gt;Target&lt;/code&gt; classes which support:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Bigquery&lt;/li&gt;
&lt;li&gt;Hadoop jobs&lt;/li&gt;
&lt;li&gt;Hive queries&lt;/li&gt;
&lt;li&gt;Pig queries&lt;/li&gt;
&lt;li&gt;Scalding jobs&lt;/li&gt;
&lt;li&gt;Spark jobs&lt;/li&gt;
&lt;li&gt;Postgresql, Redshift, Mysql tables&lt;/li&gt;
&lt;li&gt;and more… &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Source code and tests&lt;/h2&gt;
&lt;p&gt;I spent a fair amount of time digging through the Luigi Python source code. It’s pretty clean Python code with a lot of tests. Code size is about 18KLOC plus 16KLOC tests. It’s pretty easy to understand and extend.&lt;/p&gt;
&lt;h2&gt;Sample cases&lt;/h2&gt;
&lt;p&gt;Trying it out on a free &lt;a href="http://c9.io"&gt;cloud9&lt;/a&gt; Docker instance:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;pip install tornado &lt;span class="c"&gt;# luigi uses the tornado web server&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;:/home/ubuntu/workspace/luigi/bin
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;PYTHONPATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/home/ubuntu/workspace/luigi:.
&lt;span class="nv"&gt;$ &lt;/span&gt;luigid
2015-12-19 14:18:08,492 luigi-interface&lt;span class="o"&gt;[&lt;/span&gt;11022&lt;span class="o"&gt;]&lt;/span&gt; INFO: Loaded &lt;span class="o"&gt;[]&lt;/span&gt;
2015-12-19 14:18:08,494 luigi.server&lt;span class="o"&gt;[&lt;/span&gt;11022&lt;span class="o"&gt;]&lt;/span&gt; INFO: No prior state file exists at /var/lib/luigi-server/state.pickle. Starting with clean slate
2015-12-19 14:18:08,497 luigi.server&lt;span class="o"&gt;[&lt;/span&gt;11022&lt;span class="o"&gt;]&lt;/span&gt; INFO: Scheduler starting up
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In another terminal, this is the default Luigi sample to try:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;luigi/examples
&lt;span class="nv"&gt;$ &lt;/span&gt;luigi --module top_artists AggregateArtists --date-interval 2012-06
&lt;span class="c"&gt;# does the job, creates files locally!&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;luigi --module top_artists AggregateArtists --date-interval 2012-06
&lt;span class="c"&gt;# notices files are there, doesn’t do anything&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s play around with Luigi. Let’s create this x.py:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;luigi&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;luigi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WrapperTask&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;task_namespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;examples&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Running X&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;requires&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;Bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;luigi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Task&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;task_namespace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;examples&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;luigi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IntParameter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Bar &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Bar touched &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;luigi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LocalTarget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/tmp/bar/&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;And run it like:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;luigi --module x examples.X
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This will create an &lt;code&gt;X&lt;/code&gt; task and 10 &lt;code&gt;Bar&lt;/code&gt; tasks. The 10 &lt;code&gt;Bar&lt;/code&gt; tasks will touch &lt;code&gt;/tmp/bar/…&lt;/code&gt; and that’s it.
Let’s delete the tmp files, and create a similarly named y.py, with identical &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; tasks, except &lt;code&gt;X&lt;/code&gt; renamed to &lt;code&gt;Y&lt;/code&gt;. Let’s launch two workers, one with x and one with y. Notice that the central scheduler will merge the dependency graphs and treat the &lt;code&gt;Bar&lt;/code&gt; tasks coming from the different workers/codes as the same, because their &lt;code&gt;task_id&lt;/code&gt; (class name plus parameters) are identical. It’s a bit weird, but this is how Luigi works. Another thing you’ll notice is that at the end of the execution, one of &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; will be unfinished (not green on the dashboard). This is because the workers are run without &lt;code&gt;--worker-keep-alive&lt;/code&gt;. So the first worker who finishes its tasks and is waiting for the other worker to finish the last &lt;code&gt;Bar&lt;/code&gt; will exit (it’s got nothing to do). If that worker was eg. the x worker, then task &lt;code&gt;X&lt;/code&gt; is not going to be run by anyone! if we turn on &lt;code&gt;--worker-keep-alive&lt;/code&gt; in the command-line, this oddity goes away.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;When designing an ETL framework, I would make (and have made) different design decisions compared to Luigi. But if I were tasked with creating a new ETL framework from scratch (eg. at a new company), I would definitely consider using Luigi. There is simply too much useful stuff there to ignore (and re-implement).
&lt;strong&gt;However, I would expect to:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find unexpected and painful behaviour in Luigi.&lt;/li&gt;
&lt;li&gt;Write significant scaffolding code to make it useful:&lt;ol&gt;
&lt;li&gt;Syncing the task library to different workers&lt;/li&gt;
&lt;li&gt;Scheduling series of tasks&lt;/li&gt;
&lt;li&gt;Monitoring&lt;/li&gt;
&lt;li&gt;Alerting&lt;/li&gt;
&lt;li&gt;Dashboard for the ETL datasets and jobs (see below)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Downsides of Luigi:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sometimes unexpected behaviour: for example, a wrapper task can reach &lt;code&gt;DONE&lt;/code&gt; status without ever running the &lt;code&gt;run()&lt;/code&gt; method depending on non-deterministic execution order.&lt;/li&gt;
&lt;li&gt;The biggest downside to Luigi is that ETL jobs are specified as programmatic Python Task objects and not given is some sort of DSL. This means no external tool can reasonably/easily parse a library of tasks and extract dependency information, which would be useful for eg. generating documentation of the ETL system. Also, analysts have to learn Python.&lt;/li&gt;
&lt;li&gt;The web dashboard of the central scheduler is basically useless.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Links, talks&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/spotify/luigi"&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://luigi.readthedocs.org/en/stable/index.html"&gt;Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/spotify/luigi#who-uses-luigi"&gt;Slides from Luigi users&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="data"></category><category term="etl"></category><category term="workflow"></category><category term="luigi"></category></entry><entry><title>Cargo Cult Data</title><link href="/cargo-cult-data.html" rel="alternate"></link><updated>2015-12-22T00:00:00+01:00</updated><author><name>Marton Trencseni</name></author><id>tag:,2015-01-26:cargo-cult-data.html</id><summary type="html">&lt;h2&gt;Cargo cult science&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Richard_Feynman"&gt;R. P. Feynman&lt;/a&gt; was a Nobel-prize winning physicist who coined the term &lt;a href="https://en.wikipedia.org/wiki/Cargo_cult_science"&gt;cargo cult science&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In Feynman's words:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the South Seas there is a cargo cult of people. During the [second world] war they saw airplanes land with lots of good materials, and they want the same thing to happen now [after the Americans left]. So they've arranged to imitate things like runways, to put fires along the sides of the runways, to make a wooden hut for a man to sit in, with two wooden pieces on his head like headphones and bars of bamboo sticking out like antennas—he's the controller—and they wait for the airplanes to land. They're doing everything right. The form is perfect. It looks exactly the way it looked before. But it doesn't work. No airplanes land. So I call these things cargo cult science, because they follow all the apparent precepts and forms of scientific investigation, but they're missing something essential, because the planes don't land.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Feynman cautioned that to avoid becoming cargo cult scientists, researchers must avoid fooling themselves, be willing to question and doubt their own theories and their own results, and investigate possible flaws in a theory or an experiment. He recommended that researchers adopt an unusually high level of honesty which is rarely encountered in everyday life, and gave examples from advertising, politics, and behavioral psychology to illustrate the everyday dishonesty which should be unacceptable in science.&lt;/p&gt;
&lt;h2&gt;Cargo cult data&lt;/h2&gt;
&lt;p&gt;The same idea applies to data. Cargo cult data is when you're collecting and looking at data when making decisions, but you're only following the forms of scientific investigation and missing the essentials, so it doesn't work. &lt;em&gt;So in the end you're like the natives of the South Seas, and the planes don't land for you either.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Signs that you're doing cargo cult data:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;you don't have standardized logging across your products&lt;/li&gt;
&lt;li&gt;you routinely break your logging and have holes in your dataset&lt;/li&gt;
&lt;li&gt;you don't have standardized KPIs across your products and company&lt;/li&gt;
&lt;li&gt;you're not A/B testing all your releases&lt;/li&gt;
&lt;li&gt;you don't have explicit hypothesis for your experiments&lt;/li&gt;
&lt;li&gt;you don't know what statistical power is&lt;/li&gt;
&lt;li&gt;you confuse statistical significance and magnitude of change&lt;/li&gt;
&lt;li&gt;you're using online forms to evaluate A/B tests&lt;/li&gt;
&lt;li&gt;you stop A/B tests as soon as they're statistically significant (=peeking)&lt;/li&gt;
&lt;li&gt;you're not tracking your experiments and their outcomes historically&lt;/li&gt;
&lt;li&gt;you don't know what standard deviation (=confuse signal and noise)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are no easy answers how to avoid cargo cult data, just as there are no easy answers how to avoid cargo cult science. If you are thinking about this as a company, your best bet is to hire smart mathematicians or physicist for your data team and listen to what they say. Personally, it's a matter of understanding statistics and being disciplined in your work. Fortunately there are &lt;a href="https://www.coursera.org/specializations/jhu-data-science"&gt;great courses on Coursera&lt;/a&gt;, &lt;a href="http://www.amazon.com/s/ref=dp_byline_sr_book_1?ie=UTF8&amp;amp;text=Allen+B.+Downey&amp;amp;search-alias=books&amp;amp;field-author=Allen+B.+Downey&amp;amp;sort=relevancerank"&gt;great books on Amazon&lt;/a&gt; and a &lt;a href="https://en.wikipedia.org/wiki/A/B_testing"&gt;wealth of information available online&lt;/a&gt;.&lt;/p&gt;</summary><category term="data"></category></entry></feed>